<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PR0M31H3U5</title>
    <!-- <link rel="icon" type="image/png" sizes="512x512"  href="ico/icon_512.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="ico/icon_192.png">
    <link rel="icon" type="image/png" sizes="32x32"    href="ico/icon_32.png"> -->
    <link rel="stylesheet" type="text/css"             href="../css/blog.css"/>
    <link rel="stylesheet"                             href="../js/app.js">
    <script src="https://cdn.jsdelivr.net/npm/baffle@0.3.6/dist/baffle.min.js"></script>
    <script>  
      setInterval(function () {
          var now = new Date();
          var clock = document.getElementById("clock");
          clock.innerHTML = now.toLocaleTimeString();
      }, 1000);
      </script>
    <!-- <link rel="preload" href="/fonts/Sono-Regular.ttf" as="font"> -->
</head>
<body>


  <header>
    <pre>

 ________  ________  ________  _____ ______   ________    _____  ___  ___  ________  ___  ___  ________      
|\   __  \|\   __  \|\   __  \|\   _ \  _   \|\_____  \  / __  \|\  \|\  \|\_____  \|\  \|\  \|\   ____\     
 \ \  \|\  \ \  \|\  \ \  \|\  \ \  \\\__\ \  \|____|\ /_|\/_|\  \ \  \\\  \|____|\ /_ \  \\\  \ \  \___|_    
  \ \   ____\ \   _  _\ \  \\\  \ \  \\|__| \  \    \|\  \|/ \ \  \ \   __  \    \|\  \ \  \\\  \ \_____  \   
   \ \  \___|\ \  \\  \\ \  \\\  \ \  \    \ \  \  __\_\  \   \ \  \ \  \ \  \  __\_\  \ \  \\\  \|____|\  \  
    \ \__\    \ \__\\ _\\ \_______\ \__\    \ \__\|\_______\   \ \__\ \__\ \__\|\_______\ \_______\____\_\  \ 
     \|__|     \|__|\|__|\|_______|\|__|     \|__|\|_______|    \|__|\|__|\|__|\|_______|\|_______|\_________\
                                                                                                  \|_________|
    </pre>

</header>

<div class="separator"></div>

<script type="text/javascript"> 
    
    function runningline(msg,ctrlwidth)
    {
    msg = " "+msg
    newmsg = msg
    while (newmsg.length < ctrlwidth) {newmsg += msg}
    document.write ('<form name="Tekst">')
    document.write ('<input name="tekst" style="border:0;font-weight:bold;color:rgb(229, 229, 210);background-color:black; width:100%;" value= "'+newmsg+'" size= '+ctrlwidth+' />')
    document.write ('</form>')
    prokrutka()
    }
    function prokrutka()
    {
    NowMsg=document.Tekst.tekst.value
    NowMsg=NowMsg.substring(1,NowMsg.length)+NowMsg.substring(0,1)
    document.Tekst.tekst.value = NowMsg
    bannerid=setTimeout("prokrutka()",500)
    }
    </script>

    <script type="text/javascript">
    runningline("プロメテウス",500)
    </script> 

    <div class="navbar">
      <a href="../index.html" class="BtmpTxt">&lt---back to main page</a>
      <a href="#news">News</a>
      <a href="#contact">Contact</a>

      <span id="clock" style="color: rgb(229, 229, 210);"></span>
    </div>
    
    <div class="separator"></div>


      <div class="dungeon">
        <div class="MainText">
          It's just a simple bash dungeon generator <br>
          build on C++
          
        </div>
        <div class="morphBox">
          <!-- <script class="morph">
            var AsciiMorph = (function() {

  'use strict';

  var element = null;
  var canvasDimensions = {};

  var renderedData = [];
  var framesToAnimate = [];
  var myTimeout = null;

  /**
   * Utils
   */

  function extend(target, source) {
    for (var key in source) {
      if (!(key in target)) {
        target[key] = source[key];              
      }
    }
    return target;
  }

  function repeat(pattern, count) {
      if (count < 1) return '';
      var result = '';
      while (count > 1) {
          if (count & 1) result += pattern;
          count >>= 1, pattern += pattern;
      }
      return result + pattern;
  }

  function replaceAt(string, index, character ) {
    return string.substr(0, index) + character + string.substr(index+character.length);
  }

  /**
   * AsciiMorph
   */

  function init(el, canvasSize) {
    
    // Save the element
    element = el;
    canvasDimensions = canvasSize;
  }

  function squareOutData(data) {
    var i;
    var renderDimensions = {
      x: 0,
      y: data.length
    };

    // Calculate centering numbers
    for( i = 0; i < data.length; i++ ) {
      if( data[i].length > renderDimensions.x) {
        renderDimensions.x = data[i].length
      }
    }
    
    // Pad out right side of data to square it out
    for( i = 0; i < data.length; i++ ) {
      if( data[i].length < renderDimensions.x) {
        data[i] = (data[i] + repeat(' ', renderDimensions.x - data[i].length ));
      }
    }
    
    var paddings = {
      x: Math.floor((canvasDimensions.x - renderDimensions.x) / 2),
      y: Math.floor((canvasDimensions.y - renderDimensions.y) / 2)
    }
    
    // Left Padding
    for( var i = 0; i < data.length; i++ ) {
      data[i] = repeat(' ', paddings.x) + data[i] + repeat(' ', paddings.x);
    }
    
    // Pad out the rest of everything
    for( var i = 0; i < canvasDimensions.y; i++ ) {
      if( i < paddings.y) {
        data.unshift( repeat(' ', canvasDimensions.x));
      } else if (i > (paddings.y + renderDimensions.y)) {
        data.push( repeat(' ', canvasDimensions.x));
      }
    }
    
    return data;
  }

  // Crushes the frame data by 1 unit.
  function getMorphedFrame(data) {
    
    var firstInLine, lastInLine = null;
    var found = false;
    for( var i = 0; i < data.length; i++) {
      
      var line = data[i];
      firstInLine = line.search(/\S/);
      if( firstInLine === -1) {
        firstInLine = null;
      }
      
      for( var j = 0; j < line.length; j++) {
        if( line[j] != ' ') {
          lastInLine = j;
        }
      }
      
      if( firstInLine !== null && lastInLine !== null) {
        data = crushLine(data, i, firstInLine, lastInLine)
        found = true;
      }

      firstInLine = null, lastInLine = null;
    }
    
    if( found ) {
      return data;
    } else {
      return false;
    }
  }

  function crushLine(data, line, start, end) {
    
    var centers = {
      x: Math.floor(canvasDimensions.x / 2),
      y: Math.floor(canvasDimensions.y / 2)
    }
    
    var crushDirection = 1;
    if( line > centers.y ) {
      crushDirection = -1;
    }
    
    var charA = data[line][start];
    var charB = data[line][end];
    
    data[line] = replaceAt(data[line], start, " ");
    data[line] = replaceAt(data[line], end, " ");

    if( !((end - 1) == (start + 1)) && !(start === end) && !((start + 1) === end)) {
      data[line + crushDirection] = replaceAt(data[line + crushDirection], (start + 1), '+*/\\'.substr(Math.floor(Math.random()*'+*/\\'.length), 1));
      data[line + crushDirection] = replaceAt(data[line + crushDirection], (end - 1), '+*/\\'.substr(Math.floor(Math.random()*'+*/\\'.length), 1));
    } else if ((((start === end) || (start + 1) === end)) && ((line + 1) !== centers.y && (line - 1) !== centers.y && line !== centers.y)) {
      data[line + crushDirection] = replaceAt(data[line + crushDirection], (start), '+*/\\'.substr(Math.floor(Math.random()*'+*/\\'.length), 1));
      data[line + crushDirection] = replaceAt(data[line + crushDirection], (end), '+*/\\'.substr(Math.floor(Math.random()*'+*/\\'.length), 1));
    }
    
    return data;
  }

  function render(data) {
    var ourData = squareOutData(data.slice());
    renderSquareData(ourData);
  }

  function renderSquareData(data) {
    element.innerHTML = '';
    for( var i = 0; i < data.length; i++ ) {
      element.innerHTML = element.innerHTML + data[i] + '\n';
    }
    
    renderedData = data;
  }

  // Morph between whatever is current, to the new frame
  function morph(data) {
    
    clearTimeout(myTimeout);
    var frameData = prepareFrames(data.slice());
    animateFrames(frameData);
  }

  function prepareFrames(data) {
    
    var deconstructionFrames = [];
    var constructionFrames = [];

    var clonedData = renderedData
    
    // If its taking more than 100 frames, its probably somehow broken
    // Get the deconscrution frames
    for(var i = 0; i < 100; i++) {
      var newData = getMorphedFrame(clonedData);
      if( newData === false) {
        break;
      }
      deconstructionFrames.push(newData.slice(0)); 
      clonedData = newData;
    }
    
    // Get the constuction frames for the new data
    var squareData = squareOutData(data);
    constructionFrames.unshift(squareData.slice(0));
    for( var i = 0; i < 100; i++ ) {
      var newData = getMorphedFrame(squareData);
      if( newData === false) {
        break;
      }
      constructionFrames.unshift(newData.slice(0));
      squareData = newData;
    }
    
    return deconstructionFrames.concat(constructionFrames)
  }

  function animateFrames(frameData) {
    framesToAnimate = frameData;
    animateFrame();
  }

  function animateFrame() {
    myTimeout = setTimeout(function() {
      
      renderSquareData(framesToAnimate[0]);
      framesToAnimate.shift();
      if( framesToAnimate.length > 0 ) {
        animateFrame();
      }
    }, 20)

    // framesToAnimate
  }

  function main(element, canvasSize) {
    
    if( !element || !canvasSize ) {
      console.log("sorry, I need an element and a canvas size");
      return;   
    }
    
    init(element, canvasSize);
  }

  return extend(main, {
    render: render,
    morph: morph
  });

  })();

  var element = document.querySelector('pre');
  AsciiMorph(element, {x: 51,y: 28});

  var asciis = [[
  "                _ooOoo_",
  "               o8888888o",
  "               88\" . \"88",
  "               (| -_- |)",
  "               O\\  =  /O",
  "            ____/`---'\\____",
  "          .'  \\\\|     |//  `.",
  "         /  \\\\|||  :  |||//  \\",
  "        /  _||||| -:- |||||_  \\",
  "        |   | \\\\\\  -  /'| |   |",
  "        | \\_|  `\\`---'//  |_/ |",
  "        \\  .-\\__ `-. -'__/-.  /",
  "      ___`. .'  /--.--\\  `. .'___",
  "   .\"\" '<  `.___\\_<|>_/___.' _> \\\"\".",
  "  | | :  `- \\`. ;`. _/; .'/ /  .' ; |",
  "  \\  \\ `-.   \\_\\_`. _.'_/_/  -' _.' /",
  "===`-.`___`-.__\\ \\___  /__.-'_.'_.-'===",
  "                `=--=-'    "
  ],

  [
  "                             /",
  "                            /",
  "                           /;",
  "                          //",
  "                         ;/",
  "                       ,//",
  "                   _,-' ;_,,",
  "                _,'-_  ;|,'",
  "            _,-'_,..--. |",
  "    ___   .'-'_)'  ) _)\\|      ___",
  "  ,'\"\"\"`'' _  )   ) _)  ''--'''_,-'",
  "-={-o-  /|    )  _)  ) ; '_,--''",
  "  \\ -' ,`.  ) .)  _)_,''|",
  "   `.\"(   `------''     /",
  "     `.\\             _,'",
  "       `-.____....-\\\\",
  "                 || \\\\",
  "                 // ||",
  "                //  ||",
  "            _-.//_ _||_,",
  "              ,'  ,-'/"
  ],

  [
  "      \\`.     ___",
  "       \\ \\   / __>0",
  "   /\\  /  |/' / ",
  "  /  \\/   `  ,`'--.",
  " / /(___________)_ \\",
  " |/ //.-.   .-.\\\\ \\ \\",
  " 0 // :@ ___ @: \\\\ \/",
  "   ( o ^(___)^ o ) 0",
  "    \\ \\_______/ /",
  "/\\   '._______.'--.",
  "\\ /|  |<_____>    |",
  " \\ \\__|<_____>____/|__",
  "  \\____<_____>_______/",
  "      |<_____>    |",
  "      |<_____>    |",
  "      :<_____>____:",
  "     / <_____>   /|",
  "    /  <_____>  / |",
  "   /___________/  |",
  "   |           | _|__",
  "   |           | ---||_",
  "   |   |L\\/|/  |  | [__]",
  "   |  \\|||\\|\\  |  /",
  "   |           | /",
  "   |___________|/"
  ],

  [
  "     .--------.",
  "    / .------. \\",
  "   / /        \\ \\",
  "   | |        | |",
  "  _| |________| |_",
  ".' |_|        |_| '.",
  "'._____ ____ _____.'",
  "|     .'____'.     |",
  "'.__.'.'    '.'.__.'",
  "'.__  |      |  __.'",
  "|   '.'.____.'.'   |",
  "'.____'.____.'____.'",
  "'.________________.'",
  ],

  [
  "         ____",
  "        o8%8888,",
  "      o88%8888888.",
  "     8'-    -:8888b",
  "    8'         8888",
  "   d8.-=. ,==-.:888b",
  "   >8 `~` :`~' d8888",
  "   88         ,88888",
  "   88b. `-~  ':88888",
  "   888b ~==~ .:88888",
  "   88888o--:':::8888",
  "   `88888| :::' 8888b",
  "   8888^^'       8888b",
  "  d888           ,%888b.",
  " d88%            %%%8--'-.",
  "/88:.__ ,       _%-' ---  -",
  "    '''::===..-'   =  --.  `",
  ],

  [
  "      _      _      _",
  "   __(.)< __(.)> __(.)=",
  "   \\___)  \\___)  \\___)  ",
  "          _      _      _",
  "       __(.)< __(.)> __(.)=",
  "       \\___)  \\___)  \\___)   ",
  "      _      _      _",
  "   __(.)< __(.)> __(.)=",
  "   \\___)  \\___)  \\___)   ",
  "          _      _      _",
  "       __(.)< __(.)> __(.)=",
  "       \\___)  \\___)  \\___)  "
  ]];

  AsciiMorph.render(asciis[0]);

  var currentIndex = 2;

  setTimeout(function() {
  AsciiMorph.morph(asciis[1]);
  }, 1000);

  setInterval(function() {
  AsciiMorph.morph(asciis[currentIndex]);
  currentIndex++;
  currentIndex%= asciis.length;
  }, 3000);
          </script> -->
        </div>

        <textarea class="code">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class Post3 : MonoBehaviour {
    public int mapWidth;
    public int mapHeight;
    
    public int widthMinRoom;
    public int widthMaxRoom;
    public int heightMinRoom;
    public int heightMaxRoom;

    public int minCorridorLength;
    public int maxCorridorLength;
    public int maxFeatures;
    int countFeatures;

    public bool isASCII;

    public List<Feature> allFeatures;

    public void InitializeDungeon() {
        MapManager.map = new Tile[mapWidth, mapHeight];
    }

    public void GenerateDungeon() {
        GenerateFeature("Room", new Wall(), true);

        for (int i = 0; i < 500; i++) {
            Feature originFeature;

            if (allFeatures.Count == 1) {
                originFeature = allFeatures[0];
            }
            else {
                originFeature = allFeatures[Random.Range(0, allFeatures.Count - 1)];
            }

            Wall wall = ChoseWall(originFeature);
            if (wall == null) continue;

            string type;

            if (originFeature.type == "Room") {
                type = "Corridor";
            }
            else {
                if (Random.Range(0, 100) < 90) {
                    type = "Room";
                }
                else {
                    type = "Corridor";
                }
            }

            GenerateFeature(type, wall);

            if (countFeatures >= maxFeatures) break;
        }

        DrawMap(isASCII);
    }

    void GenerateFeature(string type, Wall wall, bool isFirst = false) {
        Feature room = new Feature();
        room.positions = new List<Vector2Int>();

        int roomWidth = 0;
        int roomHeight = 0;

        if (type == "Room") {
            roomWidth = Random.Range(widthMinRoom, widthMaxRoom);
            roomHeight = Random.Range(heightMinRoom, heightMaxRoom);
        }
        else {
            switch (wall.direction) {
                case "South":
                    roomWidth = 3;
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);
                    break;
                case "North":
                    roomWidth = 3;
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);
                    break;
                case "West":
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);
                    roomHeight = 3;
                    break;
                case "East":
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);
                    roomHeight = 3;
                    break;

            }
        }

        int xStartingPoint;
        int yStartingPoint;

        if (isFirst) {
            xStartingPoint = mapWidth / 2;
            yStartingPoint = mapHeight / 2;
        }
        else {
            int id;
            if (wall.positions.Count == 3) id = 1;
            else id = Random.Range(1, wall.positions.Count - 2);

            xStartingPoint = wall.positions[id].x;
            yStartingPoint = wall.positions[id].y;
        }

        Vector2Int lastWallPosition = new Vector2Int(xStartingPoint, yStartingPoint);

        if (isFirst) {
            xStartingPoint -= Random.Range(1, roomWidth);
            yStartingPoint -= Random.Range(1, roomHeight);
        }
        else {
            switch (wall.direction) {
                case "South":
                    if (type == "Room") xStartingPoint -= Random.Range(1, roomWidth - 2);
                    else xStartingPoint--;
                    yStartingPoint -= Random.Range(1, roomHeight - 2);
                    break;
                case "North":
                    if (type == "Room") xStartingPoint -= Random.Range(1, roomWidth - 2);
                    else xStartingPoint--;
                    yStartingPoint ++;
                    break;
                case "West":
                    xStartingPoint -= roomWidth;
                    if (type == "Room") yStartingPoint -= Random.Range(1, roomHeight - 2);
                    else yStartingPoint--;
                    break;
                case "East":
                    xStartingPoint++;
                    if (type == "Room") yStartingPoint -= Random.Range(1, roomHeight - 2);
                    else yStartingPoint--;
                    break;
            }
        }

         if (!CheckIfHasSpace(new Vector2Int(xStartingPoint, yStartingPoint), new Vector2Int(xStartingPoint + roomWidth - 1, yStartingPoint + roomHeight - 1))) {
            return;
        }

        room.walls = new Wall[4];

        for (int i = 0; i < room.walls.Length; i++) {
            room.walls[i] = new Wall();
            room.walls[i].positions = new List<Vector2Int>();
            room.walls[i].length = 0;

            switch (i) {
                case 0:
                    room.walls[i].direction = "South";
                    break;
                case 1:
                    room.walls[i].direction = "North";
                    break;
                case 2:
                    room.walls[i].direction = "West";
                    break;
                case 3:
                    room.walls[i].direction = "East";
                    break;
            }
        }

        for (int y = 0; y < roomHeight; y++) {
            for (int x = 0; x < roomWidth; x++) {
                Vector2Int position = new Vector2Int();
                position.x = xStartingPoint + x;
                position.y = yStartingPoint + y;

                room.positions.Add(position);

                MapManager.map[position.x, position.y] = new Tile();
                MapManager.map[position.x, position.y].xPosition = position.x;
                MapManager.map[position.x, position.y].yPosition = position.y;

                if (y == 0) {
                    room.walls[0].positions.Add(position);
                    room.walls[0].length++;
                    MapManager.map[position.x, position.y].type = "Wall";
                }
                if (y == (roomHeight - 1)) {
                    room.walls[1].positions.Add(position);
                    room.walls[1].length++;
                    MapManager.map[position.x, position.y].type = "Wall";
                }
                if (x == 0) {
                    room.walls[2].positions.Add(position);
                    room.walls[2].length++;
                    MapManager.map[position.x, position.y].type = "Wall";
                }
                if (x == (roomWidth - 1)) {
                    room.walls[3].positions.Add(position);
                    room.walls[3].length++;
                    MapManager.map[position.x, position.y].type = "Wall";
                }
                if (MapManager.map[position.x, position.y].type != "Wall") {
                    MapManager.map[position.x, position.y].type = "Floor";
                }
            }
        }

        if (!isFirst) {
            MapManager.map[lastWallPosition.x, lastWallPosition.y].type = "Floor";
            switch (wall.direction) {
                case "South":
                    MapManager.map[lastWallPosition.x, lastWallPosition.y - 1].type = "Floor";
                    break;
                case "North":
                    MapManager.map[lastWallPosition.x, lastWallPosition.y + 1].type = "Floor";
                    break;
                case "West":
                    MapManager.map[lastWallPosition.x - 1, lastWallPosition.y].type = "Floor";
                    break;
                case "East":
                    MapManager.map[lastWallPosition.x + 1, lastWallPosition.y].type = "Floor";
                    break;
            }
        }

        room.width = roomWidth;
        room.height = roomHeight;
        room.type = type;
        allFeatures.Add(room);
        countFeatures++;
    }

    bool CheckIfHasSpace(Vector2Int start, Vector2Int end) {
        for (int y = start.y; y <= end.y; y++) {
            for (int x = start.x; x <= end.x; x++) {
                if (x < 0 || y < 0 || x >= mapWidth || y >= mapHeight) return false;
                if (MapManager.map != null) return false;
            }
        }

        return true;
    }

    Wall ChoseWall(Feature feature) {
        for (int i = 0; i < 10; i++) {
            int id = Random.Range(0, 100) / 25;
            if (!feature.walls[id].hasFeature) {
                return feature.walls[id];
            }
        }
        return null;
    }

    void DrawMap(bool isASCII) {
        if (isASCII) {
            Text screen = GameObject.Find("ASCIITest").GetComponent<Text>();

            string asciiMap = "";

            for (int y = (mapHeight - 1); y >= 0; y--) {
                for (int x = 0; x < mapWidth; x++) {
                    if (MapManager.map[x, y] != null) {
                        switch (MapManager.map[x, y].type) {
                            case "Wall":
                                asciiMap += "#";
                                break;
                            case "Floor":
                                asciiMap += ".";
                                break;
                        }
                    }
                    else {
                        asciiMap += " ";
                    }

                    if (x == (mapWidth - 1)) {
                        asciiMap += "\n";
                    }
                }
            }

            screen.text = asciiMap;
        }
    }
}
        </textarea>
 

      </div>



    
    <script class="dunnut">
      const pre = document.createElement("pre");
      document.body.appendChild(pre);

                    let x=1760,
                z=0,y=0;setInterval
              (()=>{z+=.07,y+=.03;const
            a=[...new Array(x)].map( (a,r
          )=>r % 80 === 79 ?"\n":" "),r=new
        Array(x).fill(0), t= Math.cos(z),e=
        Math.sin(z),n=Math.cos(y), o=Math.sin
      (y);for(let s=0;s<6.28; s+=.07){const c
      =Math.cos(s),h=      Math.sin(s);for(let
      s=0;s<6.28;s+=          .02){const v=Math
      .sin(s),M=Math          .cos(s),i=c+2,l=1
      /(v*i*e+h*t+5          ),p=v*i*t-h*e,d=0
      |40+30*l*(M*i*n      -p*o),m=0|12+15*l*
        (M*i*o+p*n),f=0|8*((h*e-v*c*t)*n-v*c*
          e-h*t-M*c*o), y=d+80*m;m<22&&m>=0
          &&d>=0&&d<79&&l>r[y] &&(r[y]=l,
            a[y]= ".,-~:;=!*#$@"[f>0?f:0
            ])}}pre.innerHTML=a.join
                ("")},50);

      const funs = new Funs("light");
      funs.signature();
    </script>
    
<!-- 
        <div>
          <p class="backtomainpage">
            The page is still being developed. <br>
             It'll be done soon, but in the meantime, enjoy the movie!
          </p>

          <iframe width="800" height="400"
    src="https://www.youtube.com/embed/Dgwyo6JNTDA"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen>
</iframe>
        </div> -->
        

</body>